# 알고리즘 문제 목록

## 1. 그래프 탐색(BFS/DFS)

### 레벨 1
1. **섬의 개수 세기** ✅ (islands.js)
   - 설명: 0(물)과 1(땅)이 표시된 2차원 그리드에서 섬의 개수를 세는 문제
   - 구현: BFS 또는 DFS로 연결된 모든 1을 방문하여 섬의 개수 계산
   - 예시: `[[1,1,0], [1,0,0], [0,0,1]]` → 2개의 섬

2. **최단 경로 찾기** ✅ (shortestPath.js)
   - 설명: 미로에서 시작점에서 도착점까지의 최단 경로 길이 찾기
   - 구현: BFS로 시작점에서 도착점까지 최단 경로 탐색
   - 예시: `[[0,0,0], [1,1,0], [0,0,0]]` (0은 이동 가능, 1은 벽) → 최단 경로 길이: 4

### 레벨 2
1. **단어 변환** ✅ (wordTransform.js)
   - 설명: 주어진 시작 단어에서 목표 단어로 변환하는 최소 단계 수 구하기
   - 구현: BFS로 한 번에 한 글자만 변경 가능하도록 탐색
   - 예시: "hit" → "hot" → "dot" → "dog" → "cog" → 최소 단계: 4

2. **네트워크 연결 요소** ✅ (networkComponents.js)
   - 설명: 컴퓨터 네트워크에서 연결된 그룹(컴포넌트)의 수 찾기
   - 구현: DFS 또는 BFS로 연결된 각 컴포넌트 탐색
   - 예시: 컴퓨터 3대, 연결 [[0,1], [1,2]] → 연결 요소: 1개

### 레벨 3
1. **여행 경로 찾기** ✅ (findItinerary.js)
   - 설명: 주어진 항공권을 모두 사용하여 여행 경로 만들기
   - 구현: DFS와 백트래킹으로 모든 항공권을 사용하는 경로 찾기
   - 예시: [["ICN", "JFK"], ["HND", "IAD"], ["JFK", "HND"]] → 경로: ["ICN", "JFK", "HND", "IAD"]

## 2. 문자열 처리

### 레벨 1
1. **문자열 뒤집기** ✅ (reverseString.js)
   - 설명: 주어진 문자열을 뒤집는 문제
   - 구현: 반복이나 내장 함수를 사용하여 문자열 뒤집기
   - 예시: "hello" → "olleh"

2. **유효한 괄호** ✅ (validParentheses.js)
   - 설명: 괄호 문자열이 유효한지 확인하는 문제
   - 구현: 스택을 사용하여 괄호 짝이 맞는지 검증
   - 예시: "()[]{}" → true, "([)]" → false

### 레벨 2
1. **문자열 압축** ✅ (stringCompression.js)
   - 설명: 반복되는 문자를 숫자+문자 형태로 압축
   - 구현: 문자열을 순회하며 연속된 문자 개수 세기
   - 예시: "aabcccccaaa" → "a2bc5a3"

2. **가장 긴 팰린드롬 부분 문자열** ✅ (longestPalindrome.js)
   - 설명: 주어진 문자열에서 가장 긴 팰린드롬 부분 문자열 찾기
   - 구현: 중심을 기준으로 확장하는 방식으로 팰린드롬 탐색
   - 예시: "babad" → "bab" 또는 "aba"

### 레벨 3
1. **정규 표현식 매칭** ✅ (regexMatch.js)
   - 설명: 간단한 정규 표현식 패턴이 문자열과 일치하는지 확인
   - 구현: 재귀 또는 DP로 패턴 매칭 구현
   - 예시: 문자열 "aa", 패턴 "a*" → true

## 3. 완전탐색(브루트포스)

### 레벨 1
1. **모든 순열 찾기** ✅ (permutations.js)
   - 설명: 주어진 숫자 배열의 모든 순열을 찾는 문제
   - 구현: 재귀를 사용한 백트래킹으로 모든 순열 생성
   - 예시: [1, 2, 3] → [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]

2. **모든 부분집합 찾기** ✅ (subsets.js)
   - 설명: 주어진 집합의 모든 부분집합을 찾는 문제
   - 구현: 비트마스킹 또는 재귀로 모든 부분집합 생성
   - 예시: [1, 2, 3] → [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]

### 레벨 2
1. **숫자 조합** ✅ (combinations.js)
   - 설명: 1부터 9까지의 숫자 중 일부를 사용하여 합이 특정 값이 되는 모든 조합 찾기
   - 구현: 백트래킹을 사용하여 조합 탐색
   - 예시: 목표합 7 → [[1,2,4], [1,6], [2,5], [3,4], [7]]

2. **스도쿠 풀기** ✅ (sudoku.js)
   - 설명: 9x9 스도쿠 퍼즐 풀기
   - 구현: 백트래킹을 사용하여 유효한 숫자 배치 탐색
   - 예시: 일부 숫자가 채워진 스도쿠 보드 완성하기

### 레벨 3
1. **N-Queens** ✅ (nqueens.js)
   - 설명: NxN 체스보드에 N개의 퀸을 서로 공격할 수 없게 배치하는 방법 찾기
   - 구현: 백트래킹으로 유효한 퀸 배치 탐색
   - 예시: N=4 → [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]

2. **배열을 K개의 부분집합으로 분할** ✅ (partitionKSubsets.js)
   - 설명: 주어진 배열을 합이 동일한 K개의 부분집합으로 분할할 수 있는지 확인
   - 구현: 백트래킹으로 각 숫자를 K개의 부분집합 중 하나에 배치하기
   - 예시: [4, 3, 2, 3, 5, 2, 1], k=4 → 가능 (각 부분집합 합이 5)

## 4. 동적 계획법(DP)

### 레벨 1
1. **계단 오르기** ✅ (climbStairs.js)
   - 설명: 한 번에 1계단 또는 2계단을 오를 수 있을 때, n개의 계단을 오르는 방법의 수 구하기
   - 구현: DP로 이전 계단까지의 방법 수 활용
   - 예시: n=4 → 5가지 방법

2. **최대 부분합** ✅ (maxSubArray.js)
   - 설명: 배열에서 연속된 부분배열의 최대 합 구하기
   - 구현: DP로 이전까지의 최대 부분합 활용
   - 예시: [-2, 1, -3, 4, -1, 2, 1, -5, 4] → 6 (부분배열 [4, -1, 2, 1])

### 레벨 2
1. **배낭 문제** ✅ (knapsack.js)
   - 설명: 배낭에 담을 수 있는 물건의 최대 가치 계산
   - 구현: DP로 각 물건을 선택하거나 선택하지 않는 경우의 최적해 계산
   - 예시: 물건의 무게 [2, 3, 4, 5], 가치 [3, 4, 5, 6], 배낭 용량 8 → 최대 가치 10

2. **편집 거리** ✅ (editDistance.js)
   - 설명: 한 문자열을 다른 문자열로 변환하는데 필요한 최소 연산 횟수 구하기
   - 구현: DP로 문자 삽입, 삭제, 대체 연산 비용 계산
   - 예시: "horse"와 "ros" → 편집 거리: 3

### 레벨 3
1. **최장 증가 부분 수열** ✅ (lis.js)
   - 설명: 배열에서 값이 증가하는 가장 긴 부분 수열 찾기
   - 구현: DP로 각 위치까지의 최장 증가 부분 수열 길이 계산
   - 예시: [10, 9, 2, 5, 3, 7, 101, 18] → 길이 4 ([2, 5, 7, 101] 또는 [2, 3, 7, 18])

2. **정수 삼각형** ✅ (triangle.js)
   - 설명: 삼각형 모양으로 배열된 정수에서 최상단에서 최하단까지의 최대 경로 합 구하기
   - 구현: DP로 각 위치까지의 최대 경로 합 계산
   - 예시: [[5], [7,8], [2,3,4], [4,9,6,1]] → 최대 경로 합: 20 (5→8→3→4)

## 5. 자료구조 활용

### 레벨 1
1. **유효한 괄호** ✅ (validParentheses.js)
   - 설명: 주어진 괄호 문자열이 유효한지 확인
   - 구현: 스택을 사용하여 괄호 짝 검증
   - 예시: "({[]})" → true, "([)]" → false

2. **두 문자열의 아나그램 확인** ✅ (isAnagram.js)
   - 설명: 두 문자열이 서로 아나그램인지 확인
   - 구현: 해시맵을 사용하여 문자 빈도수 비교
   - 예시: "anagram"과 "nagaram" → true

### 레벨 2
1. **LRU 캐시 구현** ✅ (lruCache.js)
   - 설명: 최소 사용(Least Recently Used) 캐시 알고리즘 구현
   - 구현: 해시맵과 연결 리스트를 사용한 LRU 캐시 구현
   - 예시: 캐시 크기 2, 연산 [put(1,1), put(2,2), get(1), put(3,3), get(2)] → 출력: [1, -1]

2. **주식 매매 최적 시점** ✅ (maxProfit.js)
   - 설명: 주식 가격 배열에서 한 번의 매수와 매도로 얻을 수 있는 최대 이익 계산
   - 구현: 최소값 추적을 위한 변수 사용
   - 예시: [7, 1, 5, 3, 6, 4] → 최대 이익: 5 (1에 사서 6에 팔기)

### 레벨 3
1. **트리 순회** ✅ (treeTraversal.js)
   - 설명: 이진 트리의 전위, 중위, 후위 순회 구현
   - 구현: 재귀 또는 스택을 사용한 트리 순회
   - 예시: 트리 [1, null, 2, 3] → 전위: [1, 2, 3], 중위: [1, 3, 2], 후위: [3, 2, 1] 

## 현재 구현 상태

### 구현 완료 (26개)
- **그래프 탐색**: 5/5 (섬의 개수, 최단 경로, 단어 변환, 네트워크 연결, 여행 경로)
- **문자열 처리**: 5/5 (문자열 뒤집기, 유효한 괄호, 문자열 압축, 팰린드롬 찾기, 정규 표현식 매칭)
- **완전탐색**: 6/6 (순열, 부분집합, 숫자 조합, 스도쿠, N-Queens, K개 부분집합)
- **동적 계획법**: 6/6 (계단 오르기, 최대 부분합, 배낭 문제, 편집 거리, 최장 증가 부분 수열, 정수 삼각형)
- **자료구조 활용**: 5/5 (유효한 괄호, 아나그램 확인, LRU 캐시, 주식 매매, 트리 순회)

### 구현 필요 (0개)
- 모든 알고리즘 구현 완료! 🎉 